name: Frontend CI/CD

on:
  pull_request:
    branches: [ "develop", "main" ]

jobs:
  setup:
    name: Setup and Install Dependencies
    runs-on: ubuntu-latest
    outputs:
      pnpm_cache_hit: ${{ steps.cache-pnpm.outputs.cache-hit }}
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Cache pnpm modules
        id: cache-pnpm
        uses: actions/cache@v3
        with:
          path: ./node_modules
          key: ${{ runner.os }}-pnpm-${{ hashFiles('./pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./

  lint-and-unit-test:
    name: Lint and Unit test
    needs: setup
    if: github.event_name == 'pull_request' && github.base_ref == 'develop'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Use cached pnpm modules
        if: steps.setup.outputs.pnpm_cache_hit == 'true'
        run: echo "Using cached pnpm modules"
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
      - name: Run Lint
        run: pnpm run lint
      - name: Run Unit Test
        run: pnpm run test

  integration-test:
    name: Integration Test
    needs: setup
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./
    strategy:
      fail-fast: false
      matrix:
        # 필요에 따라 여러 설정으로 확장 (예: 다른 브라우저)
        browser: [chromium]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Use cached pnpm modules
        if: steps.setup.outputs.pnpm_cache_hit == 'true'
        run: echo "Using cached pnpm modules"
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps ${{ matrix.browser }}
      - name: Build Next.js app for testing
        run: pnpm run build
      - name: Start Next.js app for testing
        run: pnpm run start &
      - name: Wait for App to Start (Health Check)
        run: |
            TIMEOUT=30
            sleep $TIMEOUT;
            # for i in $(seq 1 $TIMEOUT); do
            #   if curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 >/dev/null 2>&1 && [ "$status" -eq "200" ]; then
            #     echo "Application is ready"
            #     exit 0
            #   fi
            #   echo "Waiting for application... ($i/$TIMEOUT)"
            #   sleep 1
            # done
            # echo "Application did not start within the timeout"
            # exit 1
      - name: Run Playwright Tests (${{ matrix.browser }})
        run: pnpm exec playwright test --project=chromium
        env:
          PLAYWRIGHT_TEST_BASE_URL: http://localhost:3000

  # build:
  #   name: Build & Push Docker Image
  #   if: |
  #     (github.base_ref == 'develop' && needs.lint-and-unit-test.result == 'success') ||
  #     (github.base_ref == 'main' && needs.integration-test.result == 'success')
  #   needs: [lint-and-unit-test, integration-test]
  #   runs-on: ubuntu-latest

  #   steps:
  #     - name: Checkout Repository
  #       uses: actions/checkout@v3

  #     - name: Determine Docker Tag
  #       id: set-tag
  #       run: |
  #         if [[ "${{ github.ref_name }}" == "develop" ]]; then
  #           echo "tag=jchanho99/frontend-dev:latest" >> $GITHUB_OUTPUT
  #         elif [[ "${{ github.ref_name }}" == "main" ]]; then
  #           echo "tag=jchanho99/frontend-prod:latest" >> $GITHUB_OUTPUT
  #         else
  #           echo "tag=jchanho99/frontend-unknown:latest" >> $GITHUB_OUTPUT
  #         fi

  #     - name: Login to Docker Hub
  #       uses: docker/login-action@v3
  #       with:
  #         username: ${{ secrets.DOCKER_USERNAME }}
  #         password: ${{ secrets.DOCKER_TOKEN }}

  #     - name: Build and Push Docker Image
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: .
  #         file: ./Dockerfile
  #         push: true
  #         tags: ${{ steps.set-tag.outputs.tag }}

  build-dev:
    name: Build and Push Docker (dev)
    needs: [lint-and-unit-test]
    if: github.event_name == 'pull_request' && github.base_ref == 'develop'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: jchanho99/frontend-develop:latest

  build-prod:
    name: Build and Push Docker (prod)
    needs: [integration-test]
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Get short commit SHA
        id: get_sha
        run: echo "SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)" >> "$GITHUB_ENV"
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: jchanho99/frontend-prod:${{ env.SHORT_SHA }}
  
  deploy-dev:
    name: Deploy to Dev Server
    # if: github.event.pull_request.merged == true && github.base_ref == 'develop' # PR이 develop에 merge되었을 때 실행
    if: github.event_name == 'pull_request' && github.base_ref == 'develop'
    needs: [build-dev]
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - name: Deploy to Dev
        id: deploy-step
        uses: appleboy/ssh-action@v1.0.3 # 특정 버전 사용 권장
        with:
          host: ${{ secrets.LEAFRESH_DEV_HOST }}
          username: ${{ secrets.LEAFRESH_DEV_SSH_USER }} # 개발 서버 SSH 사용자 이름 Secret
          key: ${{ secrets.LEAFRESH_DEV_SSH }}
          port: ${{ secrets.LEAFRESH_DEV_SSH_PORT || 22 }} # 개발 서버 SSH 포트 Secret (없으면 22)
          script: |
            set -e # 오류 발생 시 즉시 스크립트 중단
            IMAGE="jchanho99/frontend-develop:latest"
            cd /opt/frontend/
            echo "PWD: $(pwd)"
            sudo docker compose down
            sudo docker rm frontend-develop || true # frontend-develop 컨테이너 삭제 (오류 무시)
            sudo docker compose up -d
            
      - name: Set Status (Dev)
        id: set-status
        if: success()
        run: echo "status=success" >> "$GITHUB_OUTPUT"

      - name: Set Status (Dev Failure)
        if: failure() && steps.deploy-step.outcome == 'failure' # deploy-step이 실패했을 때만
        run: echo "status=failure" >> "$GITHUB_OUTPUT"

  deploy-prod:
    name: Deploy to Prod Server (Blue-Green)
    # if: github.event.pull_request.merged == true && github.base_ref == 'main' # PR이 main에 merge되었을 때 실행
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    needs: [build-prod]
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - name: Deploy to Prod
        id: deploy-step
        uses: appleboy/ssh-action@v1.0.3 # 특정 버전 사용 권장
        with:
          host: ${{ secrets.LEAFRESH_PROD_HOST }}
          username: ${{ secrets.LEAFRESH_PROD_SSH_USER }} # 프로덕션 서버 SSH 사용자 이름 Secret
          key: ${{ secrets.FE_SSH_PRIVATE_KEY }}
          port: ${{ secrets.LEAFRESH_PROD_SSH_PORT || 22 }} # 프로덕션 서버 SSH 포트 Secret (없으면 22)
          script: |
            set -e # 오류 발생 시 즉시 스크립트 중단
            IMAGE="jchanho99/frontend-prod:${{ env.SHORT_SHA }}"
            HEALTH_CHECK_URL="http://localhost:3001" # 헬스 체크 URL

            echo "🚀 Starting Prod Blue-Green Deployment to host: ${{ secrets.LEAFRESH_PROD_HOST }}"
            echo "🖼️ Using image: $IMAGE"

            cd /opt/frontend/
            echo "PWD: $(pwd)"

            echo "🚚 Pulling Docker image: $IMAGE"
            sudo docker pull "$IMAGE"

            CURRENT=$(cat /opt/frontend-current 2>/dev/null || echo blue)
            NEXT=$([ "$CURRENT" = "blue" ] && echo green || echo blue)

            echo "🔵 Current active environment: $CURRENT"
            echo "🟢 Next environment to deploy: $NEXT"
            
            # 참고: 아래 docker compose up -d 명령은 /opt/frontend/docker-compose.yml 파일을 사용합니다.
            # 이 docker-compose.yml 파일이 $NEXT 환경 (예: frontend-green 서비스)을 
            # 올바르게 시작하거나 업데이트하도록 구성되어 있어야 합니다.
            # (예: docker-compose.yml 내부에 blue, green 서비스가 모두 정의되어 있거나, 
            # 환경변수를 통해 타겟 서비스의 이미지가 동적으로 설정되는 등)
            echo "🚀 Bringing up $NEXT environment (frontend-$NEXT)..."
            # 만약 docker-compose.yml에서 $NEXT에 해당하는 특정 서비스를 지정해야 한다면,
            # 예: sudo docker compose up -d service-$NEXT
            # 현재는 전체 compose up을 수행합니다.
            sudo docker compose up -d # 이 명령이 frontend-$NEXT 컨테이너를 시작/업데이트해야 함

            echo "🩺 Performing health check for $NEXT on $HEALTH_CHECK_URL..."
            HEALTH_CHECK_PASSED=false
            for i in {1..60}; do
              # 포트 리스닝 확인 (nc 명령어가 서버에 설치되어 있어야 함)
              if nc -z localhost 3001 2>/dev/null; then
                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL")
                if [ "$HTTP_CODE" -eq 200 ]; then
                  # 원본 스크립트의 <title> 태그 확인 로직
                  CONTENT_STATUS=$(curl -s "$HEALTH_CHECK_URL" | grep "<title>")
                  if [ ! -z "$CONTENT_STATUS" ]; then
                    echo "✅ Health check passed for $NEXT on attempt $i (HTTP $HTTP_CODE with <title>)."
                    HEALTH_CHECK_PASSED=true
                    break
                  else
                    echo "⏳ Waiting ($i)... Health check for $NEXT: HTTP $HTTP_CODE but <title> not found. Retrying..."
                  fi
                else
                  echo "⏳ Waiting ($i)... Health check for $NEXT: Failed with HTTP status $HTTP_CODE. Retrying..."
                fi
              else
                echo "⏳ Waiting ($i)... Health check for $NEXT: Port 3001 not listening. Retrying..."
              fi
              sleep 1
            done

            if [ "$HEALTH_CHECK_PASSED" != "true" ]; then
              echo "❌ Health check failed for $NEXT environment after 60 attempts."
              echo "💣 Rolling back: Attempting to stop and remove $NEXT environment (frontend-$NEXT)..."
              sudo docker stop "frontend-$NEXT" || true
              sudo docker rm "frontend-$NEXT" || true
              # 필요시 이전 $CURRENT 환경을 명시적으로 다시 활성화하는 로직 추가 가능
              exit 1
            fi

            echo "✅ Health check successful for $NEXT environment."
            echo "🔄 Switching traffic..."

            echo "🛑 Stopping and removing $CURRENT environment (frontend-$CURRENT)..."
            sudo docker stop "frontend-$CURRENT" || true
            sudo docker rm "frontend-$CURRENT" || true
            
            # --- 원본 스크립트의 로직 유지 ---
            # 성공적으로 헬스체크된 $NEXT 환경을 중지, 삭제 후 다시 docker compose up 하는 부분입니다.
            # 특정 이유가 있을 수 있으므로 원본 로직을 유지합니다.
            # 일반적인 Blue/Green에서는 이 부분이 필요 없을 수 있습니다 (이미 $NEXT는 잘 실행 중).
            # 대신, 이 시점에서 리버스 프록시 설정을 변경하여 트래픽을 $NEXT로 전환합니다.
            echo "⚠️ Force restarting $NEXT environment as per original script logic (stop, rm, up)..."
            sudo docker stop "frontend-$NEXT" || true
            sudo docker rm "frontend-$NEXT" || true
            sudo docker compose up -d # $NEXT 환경을 다시 시작
            # --- 원본 스크립트 로직 끝 ---

            echo "$NEXT" > /opt/frontend-current
            echo "🎉 Prod Blue-Green deployment to $NEXT complete. $NEXT is now active."

      - name: Set Status (Prod)
        id: set-status
        if: success()
        run: echo "status=success" >> "$GITHUB_OUTPUT"

      - name: Set Status (Prod Failure)
        if: failure() && steps.deploy-step.outcome == 'failure' # deploy-step이 실패했을 때만
        run: echo "status=failure" >> "$GITHUB_OUTPUT"
  
  notify:
    name: Discord Notification
    needs: [deploy-dev, deploy-prod]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Send Discord Message
        run: |
          MESSAGE=""

          # Check Dev Deploy Status
          if [ "${{ needs.deploy-dev.result }}" != "" ]; then
            STATUS_DEV="${{ needs.deploy-dev.outputs.status }}"
            if [ "$STATUS_DEV" = "success" ]; then
              MESSAGE="${MESSAGE}✅ \`[FE develop]\` 배포 완료\n"
            elif [ "$STATUS_DEV" = "failure" ]; then
              MESSAGE="${MESSAGE}🚨 \`[FE develop]\` 배포 실패\n"
            fi
          fi

          # Check Prod Deploy Status
          if [ "${{ needs.deploy-prod.result }}" != "" ]; then
            STATUS_PROD="${{ needs.deploy-prod.outputs.status }}"
            if [ "$STATUS_PROD" = "success" ]; then
              MESSAGE="${MESSAGE}✅ \`[FE prod]\` 배포 완료 (Blue-Green)\n"
            elif [ "$STATUS_PROD" = "failure" ]; then
              MESSAGE="${MESSAGE}🚨 \`[FE prod]\` 배포 실패 (헬스체크 실패 등)\n"
            fi
          fi

          if [ -z "$MESSAGE" ]; then
            MESSAGE="⚠️ 배포 상태 정보를 찾을 수 없습니다."
          fi

          curl -H "Content-Type: application/json" \
               -X POST \
               -d "{\"content\": \"$MESSAGE\"}" \
               ${{ secrets.DISCORD_WEBHOOK_URL }}
